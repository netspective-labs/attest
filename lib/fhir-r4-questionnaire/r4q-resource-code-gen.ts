/**
 * @file r4q-resource-to-ts.ts
 * CLI code generator: FHIR R4 Questionnaire â†’ type-safe `.auto.ts` modules.
 *
 * Usage:
 *   deno run -A ./r4q-resource-to-ts.ts ./A.json ./B.json --outDir ./out --force
 *   deno run -A ./r4q-resource-to-ts.ts ./Company-Information.json --stdout
 */

import * as path from "jsr:@std/path@^1.1.2";

import {
    FhirQuestionnaire,
    FieldMeta,
    flattenItems,
    toCamelCase,
    toKebabCase,
    toPascalCase,
} from "./r4q-runtime.ts";

/** Left-pad each line in a string by `n` two-space indents. */
export function indent(s: string, n = 1): string {
    const pad = "  ".repeat(n);
    return s.split("\n").map((line) => (line.length ? pad + line : line)).join(
        "\n",
    );
}

/** Banner at the top of each generated file. */
export function renderHeaderBanner(
    filename: string,
    form: FhirQuestionnaire,
    titleCamel: string,
    titlePascal: string,
    titleKebab: string,
): string {
    const title = form.title ?? form.name ?? "(untitled Questionnaire)";
    const profiles = form.meta?.profile?.length
        ? "\n * Profiles: " + form.meta!.profile!.join(", ")
        : "";
    return `/**
 * @file ${filename}
 * @generated This file was auto-generated from the FHIR R4 Questionnaire "${title}".
 * Do not edit this file manually; re-run the generator if the source Questionnaire changes.${profiles}
 *
 * Normalizes LHC JSON and FHIR QuestionnaireResponse into the type-safe \`${titlePascal}\` interface.
 */

// this is the module signature, used by importers to identify the module
// using r4q-runtime.ts \`moduleSignature\` function
export const ${titleCamel}ModuleSignature: rt.ModuleSignature = {
    title: "${title}",
    filename: "${filename}",
    titleCamel: "\`${titleCamel}\`",
    titlePascal: "\`${titlePascal}\`",
    titleKebab: "\`${titleKebab}\`",
    lhcFormResponseAdapterFnName: "${titleCamel}LhcFormResponseAdapter",
    fhirQuestionnaireResponseAdapterFnName: "${titleCamel}FhirQuestionnaireResponseAdapter",
    sourceTextConstName: "${titleCamel}Source",
}

// deno-lint-ignore no-explicit-any
type Any = any;
`;
}

/** Optional block summarizing collected help notes. */
export function renderFormHelpsBlock(formHelps: string[]): string {
    if (!formHelps.length) return "";
    const lines = formHelps.map((h) => ` * - ${h.replace(/\*\//g, "*\\/")}`)
        .join("\n");
    return `/**
 * Form Help (from display/help controls):
${lines}
 */
`;
}

/** The single import line used by generated files. */
export function renderSharedImports(importPath = "./r4q-runtime.ts"): string {
    // Normalize to POSIX-style for Deno import consistency
    const norm = importPath.replace(/\\/g, "/");
    const prefixed = norm.startsWith(".") ? norm : `./${norm}`;
    return `import * as rt from "${prefixed}";\n`;
}

/** Emit the `<title>LinkIds` constant. */
export function renderLinkIdMap(
    titleCamel: string,
    _titlePascal: string,
    fields: FieldMeta[],
): string {
    const name = `${titleCamel}LinkIds`;
    const entries = fields.map((f) =>
        `  ${f.propName}: ${JSON.stringify(f.linkId)}`
    ).join(",\n");
    return `/** Map of normalized property names to their source \`linkId\`. */
export const ${name} = {
${entries}
} as const;

`;
}

/** Emit the main interface with rich JSDoc per property. */
export function renderInterface(
    titlePascal: string,
    formTitle: string,
    fields: FieldMeta[],
): string {
    const propLines = fields.map((f) => {
        const secTrail = f.groupTrail.length
            ? `\n * Section: ${f.groupTrail.join(" > ")}`
            : "";
        const entryFmt = f.entryFormat
            ? `\n * Entry format: ${f.entryFormat}`
            : "";
        const choiceInfo = f.choiceLiterals?.length
            ? `\n * Options: ${
                f.choiceLiterals.map((s) => JSON.stringify(s)).join(", ")
            }`
            : "";
        const req = f.required ? "\n * Required: yes" : "\n * Required: no";
        const doc = `/**\n * ${
            f.text ?? "(no label)"
        }\n * linkId: ${f.linkId}\n * FHIR type: ${f.fhirType}${entryFmt}${secTrail}${choiceInfo}${req}\n */`;
        const optional = f.required ? "" : "?";
        return `${doc}\n${f.propName}${optional}: ${f.tsType};`;
    }).join("\n\n");

    return `/** Normalized view of "${formTitle}" answers. */
export interface ${titlePascal} {
${indent(propLines, 1)}
}

`;
}

/** Decide which coercer to call given a FieldMeta and raw expression string. */
export function coerceExprByType(f: FieldMeta, rawExpr: string): string {
    // Arrays (multi-answer/repeats)
    if (f.repeats) {
        // For choice repeats we coerce to string[]
        return f.required
            ? `rt.coerceStringArray(${rawExpr}) as ${f.formTitlePascalCase}["${f.propName}"]`
            : `rt.coerceOptionalStringArray(${rawExpr}) as ${f.formTitlePascalCase}["${f.propName}"]`;
    }

    // If this is a string-literal union, we still coerce with string
    if (/\|/.test(f.tsType)) {
        return f.required
            ? `rt.coerceString(${rawExpr}) as ${f.formTitlePascalCase}["${f.propName}"]`
            : `rt.coerceOptionalString(${rawExpr}) as ${f.formTitlePascalCase}["${f.propName}"]`;
    }
    if (f.tsType === "string") {
        return f.required
            ? `rt.coerceString(${rawExpr})`
            : `rt.coerceOptionalString(${rawExpr})`;
    }
    if (f.tsType === "number") {
        return f.required
            ? `rt.coerceNumber(${rawExpr})`
            : `rt.coerceOptionalNumber(${rawExpr})`;
    }
    if (f.tsType === "boolean") {
        return f.required
            ? `rt.coerceBoolean(${rawExpr})`
            : `rt.coerceOptionalBoolean(${rawExpr})`;
    }
    if (f.tsType === "Date") {
        return f.required
            ? `rt.coerceDate(${rawExpr})`
            : `rt.coerceOptionalDate(${rawExpr})`;
    }
    // default fallback
    return f.required
        ? `rt.coerceString(${rawExpr})`
        : `rt.coerceOptionalString(${rawExpr})`;
}

/** Emit the LHC adapter function. */
export function renderLhcAdapter(
    titleCamel: string,
    titlePascal: string,
    fields: FieldMeta[],
): string {
    const funcName = `${titleCamel}LhcFormResponseAdapter`;
    const body = fields.map((f) => {
        const raw = `rt.findLhcValueByLinkId(input, ${
            JSON.stringify(f.linkId)
        })`;
        const coerced = coerceExprByType(f, raw);
        return `  ${f.propName}: ${coerced},`;
    }).join("\n");
    return `/** Convert an LHC JSON response into a normalized ${titlePascal} object. */
export function ${funcName}(input: Any): ${titlePascal} {
  return {
${body}
  };
}

`;
}

/** Emit the QuestionnaireResponse adapter function. */
export function renderQrAdapter(
    titleCamel: string,
    titlePascal: string,
    fields: FieldMeta[],
): string {
    const funcName = `${titleCamel}FhirQuestionnaireResponseAdapter`;
    const body = fields.map((f) => {
        const raw = f.repeats
            ? `rt.findQrAnswersByLinkId(qr, ${JSON.stringify(f.linkId)})`
            : `rt.findQrAnswerByLinkId(qr, ${JSON.stringify(f.linkId)})`;
        const coerced = coerceExprByType(f, raw);
        return `  ${f.propName}: ${coerced},`;
    }).join("\n");
    return `/** Convert a FHIR QuestionnaireResponse into a normalized ${titlePascal} object. */
export function ${funcName}(qr: Any): ${titlePascal} {
  return {
${body}
  };
}

`;
}

/** Emit the Interpreter class with factories and validation. */
export function renderInterpreter(
    titleCamel: string,
    titlePascal: string,
    formTitle: string,
    fields: FieldMeta[],
): string {
    const requiredKeys = fields.filter((f) => f.required).map((f) =>
        JSON.stringify(f.propName)
    ).join(", ");
    const allKeys = fields.map((f) => JSON.stringify(f.propName)).join(", ");
    const className = `${titlePascal}Interpreter`;
    const lhcFn = `${titleCamel}LhcFormResponseAdapter`;
    const qrFn = `${titleCamel}FhirQuestionnaireResponseAdapter`;

    return `/**
 * NOTE TO DEVELOPERS:
 * -------------------
 * This Interpreter class is provided only as an EXAMPLE scaffold to demonstrate
 * how to consume the normalized type-safe interface generated for this
 * Questionnaire. It shows minimal factories (\`fromLhc\`, \`fromQuestionnaireResponse\`)
 * and convenience methods (\`validateRequiredFields\`, \`assessReadiness\`) but it is
 * NOT intended for production use.
 *
 * In real applications:
 * - Treat this class as SAMPLE CODE only.
 * - Replace or extend it with proper business logic, rules engines, or validation
 *   frameworks appropriate to your domain.
 * - Do not rely on the simplistic readiness scoring or validation in production
 *   scenarios; they are illustrative, not authoritative.
 *
 * Best practice: use the generated TypeScript interface (\`${titlePascal}\`) as your
 * contract for normalized data, then integrate with your own rules processors,
 * compliance engines, or plain TypeScript/JavaScript functions as needed.
 */
export class ${className} {
  constructor(readonly value: ${titlePascal}) {}

  /** Factory: build from LHC JSON. */
  static fromLhcFormResponse(input: Any): ${className} {
    return new ${className}(${lhcFn}(input));
  }

  /** Factory: build from FHIR QuestionnaireResponse. */
  static fromQuestionnaireResponse(qr: Any): ${className} {
    return new ${className}(${qrFn}(qr));
  }

  /** Check required fields and report any missing or blank. */
  validateRequiredFields(): { ok: boolean; missing: Array<keyof ${titlePascal}> } {
    const missing: Array<keyof ${titlePascal}> = [];
    const req: Array<keyof ${titlePascal}> = [${requiredKeys}];
    for (const k of req) {
      const v = (this.value as Any)[k];
      if (rt.isBlank(v)) missing.push(k);
    }
    return { ok: missing.length === 0, missing };
  }

  /**
   * Assess readiness with a simple completeness score. This is meant to be
   * used to help understand how complete the types are and serves as an
   * example of how to use the generated code.
   * - requiredCovered: percentage of required fields that are non-blank
   * - overallFilled: count of non-blank fields among all known properties
   */
  assessReadiness(): {
    formTitle: string;
    requiredCovered: number; // 0..1
    totalRequired: number;
    totalFilled: number;
    totalFields: number;
    missingRequired: Array<keyof ${titlePascal}>;
  } {
    const req: Array<keyof ${titlePascal}> = [${requiredKeys}];
    const all: Array<keyof ${titlePascal}> = [${allKeys}];

    let reqFilled = 0;
    const missingReq: Array<keyof ${titlePascal}> = [];
    for (const k of req) {
      const v = (this.value as Any)[k];
      if (!rt.isBlank(v)) reqFilled++;
      else missingReq.push(k);
    }

    let totalFilled = 0;
    for (const k of all) {
      if (!rt.isBlank((this.value as Any)[k])) totalFilled++;
    }

    return {
      formTitle: ${JSON.stringify(formTitle)},
      requiredCovered: req.length ? reqFilled / req.length : 1,
      totalRequired: req.length,
      totalFilled,
      totalFields: all.length,
      missingRequired: missingReq,
    };
  }
}

`;
}

export function renderSource(q: FhirQuestionnaire, titleCamel: string): string {
    return `/** The original source */\nexport const ${titleCamel}Source = \`${
        JSON.stringify(q, null, 2)
    }\`;`;
}

export async function readJsonFile<T = unknown>(filePath: string): Promise<T> {
    try {
        const text = await Deno.readTextFile(filePath);
        return JSON.parse(text) as T;
    } catch (e) {
        throw new Error(
            `Failed to read/parse JSON at ${filePath}: ${
                e instanceof Error ? e.message : String(e)
            }`,
        );
    }
}

/** Compute the import path from an output file to r4q-runtime.ts.
 * If the output file is remote, return a remote import URL.
 */
function computeCommonImportPathFor(outFile: string): string {
    const runtimeFile = "r4q-runtime.ts";

    // Detect if outFile is a remote URL
    const isRemote = /^(https?:|jsr:)/.test(outFile);

    if (isRemote) {
        // If this file itself was loaded remotely, reuse its base
        if (import.meta.url.startsWith("http")) {
            const baseUrl = new URL(import.meta.url);
            baseUrl.pathname = baseUrl.pathname.replace(/[^/]+$/, runtimeFile);
            return baseUrl.href;
        }
        // Otherwise, default to a canonical remote location (customize as needed)
        return `./${runtimeFile}`;
    }

    // --- Local path handling ---
    const thisDir = path.dirname(path.fromFileUrl(import.meta.url));
    const commonAbs = path.join(thisDir, runtimeFile);
    const outDir = path.dirname(path.resolve(outFile));
    let rel = path.relative(outDir, commonAbs).replace(/\\/g, "/");
    if (!rel.startsWith(".")) rel = "./" + rel;
    return rel;
}

/** Ensure directory exists. */
async function ensureDir(dir: string) {
    await Deno.mkdir(dir, { recursive: true }).catch(() => {});
}

/* ========================================================================== *
 * Code assembly
 * ========================================================================== */

function assembleFile(
    q: FhirQuestionnaire,
    fields: FieldMeta[],
    formHelps: string[],
    outFileName: string,
    commonImportPath: string,
    includeSrc: boolean,
): string {
    const formTitle = q.title ?? q.name ?? "(untitled Questionnaire)";
    const titlePascal = toPascalCase(formTitle);
    const titleCamel = toCamelCase(formTitle);
    const header = renderHeaderBanner(
        path.basename(outFileName),
        q,
        titleCamel,
        titlePascal,
        toKebabCase(formTitle),
    );
    const importLine = renderSharedImports(commonImportPath);
    const helps = renderFormHelpsBlock(formHelps); // placed after import to satisfy "import immediately after banner"
    const linkIds = renderLinkIdMap(titleCamel, titlePascal, fields);
    const iface = renderInterface(titlePascal, formTitle, fields);
    const lhc = renderLhcAdapter(titleCamel, titlePascal, fields);
    const qr = renderQrAdapter(titleCamel, titlePascal, fields);
    const interp = renderInterpreter(
        titleCamel,
        titlePascal,
        formTitle,
        fields,
    );
    const src = includeSrc
        ? renderSource(q, titleCamel)
        : "/** FYI: No source request **/";

    return [
        importLine,
        header,
        helps,
        linkIds,
        iface,
        lhc,
        qr,
        interp,
        src,
    ].join("");
}

export async function generateTsCodeForQuestionnaire(
    inPath: string,
    options: {
        stdout?: boolean;
        outDir?: string;
        force?: boolean;
        includeSrc?: boolean;
    },
    results: string[],
) {
    try {
        const q = await readJsonFile<FhirQuestionnaire>(inPath);

        if (!q || q.resourceType !== "Questionnaire") {
            return new Error(
                `Not a FHIR Questionnaire (resourceType="${
                    // deno-lint-ignore no-explicit-any
                    (q as any)?.resourceType}")`,
            );
        }

        const formTitle = q.title ?? q.name;
        if (!formTitle || !formTitle.trim()) {
            return new Error(
                "Questionnaire missing a non-empty `title` or `name`.",
            );
        }

        // Flatten fields in traversal order
        const used = new Set<string>();
        if (!Array.isArray(q.item) || q.item.length === 0) {
            return new Error("Questionnaire has no `item` entries.");
        }
        const { fields, formHelp } = flattenItems(
            toCamelCase(formTitle),
            toPascalCase(formTitle),
            q.item,
            used,
        );

        // Derive filenames/paths
        const kebab = toKebabCase(formTitle);
        const fileName = `${kebab}.auto.ts`;

        const outPath = options.outDir
            ? path.join(options.outDir, fileName)
            : path.join(path.dirname(path.resolve(inPath)), fileName);

        const commonImportPath = computeCommonImportPathFor(outPath);
        const content = assembleFile(
            q,
            fields,
            formHelp,
            outPath,
            commonImportPath,
            options.includeSrc ?? false,
        );

        if (options.stdout) {
            results.push(content);
        } else {
            await ensureDir(path.dirname(outPath));
            const exists = await Deno.stat(outPath).then(() => true)
                .catch(() => false);
            if (exists && !options.force) {
                throw new Error(
                    `Refusing to overwrite existing file without --force: ${outPath}`,
                );
            }
            await Deno.writeTextFile(outPath, content);
        }
    } catch (e) {
        return e instanceof Error ? e : Error(String(e));
    }
    return false;
}
